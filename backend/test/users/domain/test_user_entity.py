import uuid

import pytest
from pydantic import ValidationError

from contexts.users.domain.entities import User
from core.security import verify_password  # To check password hashing


def test_create_user_entity_success():
    """Test successful creation of a User entity."""
    user_id = uuid.uuid4()
    user = User(
        id=user_id,
        name="Test User",
        email="test@example.com",
        hashed_password="some_prehashed_password",  # In real creation, use set_password
    )
    assert user.id == user_id
    assert user.name == "Test User"
    assert user.email == "test@example.com"
    assert user.hashed_password == "some_prehashed_password"
    assert user.is_active is True


def test_create_user_entity_default_id():
    """Test that a UUID is generated by default if not provided."""
    user = User(
        name="Test User", email="test@example.com", hashed_password="some_password"
    )
    assert isinstance(user.id, uuid.UUID)


def test_create_user_entity_invalid_email():
    """Test creation fails with invalid email format."""
    with pytest.raises(ValidationError):
        User(name="Test User", email="invalid-email", hashed_password="some_password")


def test_create_user_entity_empty_name():
    """Test creation fails if name is empty or whitespace."""
    with pytest.raises(ValidationError) as excinfo:
        User(name="   ", email="test@example.com", hashed_password="some_password")
    assert "Name must not be empty" in str(excinfo.value)

    with pytest.raises(ValidationError) as excinfo:
        User(name="", email="test@example.com", hashed_password="some_password")
    # Pydantic v2 might raise different error detail for empty vs missing
    # Check for relevant message
    assert "name" in str(excinfo.value).lower()  # Check field name involved


def test_set_password():
    """Test setting and hashing the password."""
    user = User(name="Test", email="test@example.com", hashed_password="")
    plain_password = "valid_password123"
    user.set_password(plain_password)

    assert user.hashed_password != plain_password  # Ensure it's hashed
    assert len(user.hashed_password) > 0  # Ensure hash is generated
    assert verify_password(plain_password, user.hashed_password)  # Check verification


def test_set_password_too_short():
    """Test setting password fails if too short."""
    user = User(name="Test", email="test@example.com", hashed_password="")
    with pytest.raises(ValueError) as excinfo:
        user.set_password("short")
    assert "Password must be at least 8 characters long" in str(excinfo.value)


def test_check_password_correct():
    """Test checking a correct password."""
    user = User(name="Test", email="test@example.com", hashed_password="")
    plain_password = "valid_password123"
    user.set_password(plain_password)

    assert user.check_password(plain_password) is True


def test_check_password_incorrect():
    """Test checking an incorrect password."""
    user = User(name="Test", email="test@example.com", hashed_password="")
    plain_password = "valid_password123"
    user.set_password(plain_password)

    assert user.check_password("wrong_password") is False


def test_activate_user():
    """Test activating an inactive user."""
    user = User(
        name="Test", email="test@example.com", hashed_password="hash", is_active=False
    )
    user.activate()
    assert user.is_active is True


def test_activate_already_active_user():
    """Test activating an already active user (should have no effect)."""
    user = User(
        name="Test", email="test@example.com", hashed_password="hash", is_active=True
    )
    user.activate()  # Should not raise error by default
    assert user.is_active is True


def test_deactivate_user():
    """Test deactivating an active user."""
    user = User(
        name="Test", email="test@example.com", hashed_password="hash", is_active=True
    )
    user.deactivate()
    assert user.is_active is False


def test_deactivate_already_inactive_user():
    """Test deactivating an already inactive user (should have no effect)."""
    user = User(
        name="Test", email="test@example.com", hashed_password="hash", is_active=False
    )
    user.deactivate()  # Should not raise error by default
    assert user.is_active is False
